"""
Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ - Main Financial Analysis Engine
ÙŠØ¯ÙŠØ± ÙˆÙŠØ±Ø¨Ø· Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ø§Ù„Ù€ 180
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from typing import Dict, Any, List, Optional
import logging
from datetime import datetime
import json

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¬Ù…ÙŠØ¹ ÙØ¦Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„
from analysis_types.liquidity_analysis import LiquidityAnalysis
from analysis_types.profitability_analysis import ProfitabilityAnalysis
from analysis_types.efficiency_analysis import EfficiencyAnalysis
from analysis_types.leverage_analysis import LeverageAnalysis
from analysis_types.market_analysis import MarketAnalysis
from analysis_types.investment_analysis import InvestmentAnalysis

class FinancialAnalysisEngine:
    """Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„"""

    def __init__(self):
        self.analysis_engines = {
            'liquidity': LiquidityAnalysis(),
            'profitability': ProfitabilityAnalysis(),
            'efficiency': EfficiencyAnalysis(),
            'leverage': LeverageAnalysis(),
            'market': MarketAnalysis(),
            'investment': InvestmentAnalysis()
        }

        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø¬Ù„Ø§Øª
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

        # Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø­Ø©
        self.available_analyses = {
            # ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (10)
            'current_ratio': {'engine': 'liquidity', 'method': 'current_ratio'},
            'quick_ratio': {'engine': 'liquidity', 'method': 'quick_ratio'},
            'cash_ratio': {'engine': 'liquidity', 'method': 'cash_ratio'},
            'working_capital': {'engine': 'liquidity', 'method': 'working_capital'},
            'operating_cash_flow_ratio': {'engine': 'liquidity', 'method': 'operating_cash_flow_ratio'},
            'days_inventory_outstanding': {'engine': 'liquidity', 'method': 'days_inventory_outstanding'},
            'days_payable_outstanding': {'engine': 'liquidity', 'method': 'days_payable_outstanding'},
            'working_capital_ratio': {'engine': 'liquidity', 'method': 'working_capital_ratio'},
            'cash_to_current_liabilities': {'engine': 'liquidity', 'method': 'cash_to_current_liabilities'},
            'liquidity_index': {'engine': 'liquidity', 'method': 'liquidity_index'},

            # ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ø±Ø¨Ø­ÙŠØ© (15)
            'gross_profit_margin': {'engine': 'profitability', 'method': 'gross_profit_margin'},
            'operating_profit_margin': {'engine': 'profitability', 'method': 'operating_profit_margin'},
            'net_profit_margin': {'engine': 'profitability', 'method': 'net_profit_margin'},
            'return_on_assets': {'engine': 'profitability', 'method': 'return_on_assets'},
            'return_on_equity': {'engine': 'profitability', 'method': 'return_on_equity'},
            'return_on_investment': {'engine': 'profitability', 'method': 'return_on_investment'},
            'earnings_per_share': {'engine': 'profitability', 'method': 'earnings_per_share'},
            'price_to_earnings_ratio': {'engine': 'profitability', 'method': 'price_to_earnings_ratio'},
            'dividend_yield': {'engine': 'profitability', 'method': 'dividend_yield'},
            'dividend_payout_ratio': {'engine': 'profitability', 'method': 'dividend_payout_ratio'},
            'ebitda_margin': {'engine': 'profitability', 'method': 'ebitda_margin'},
            'operating_leverage': {'engine': 'profitability', 'method': 'operating_leverage'},
            'asset_turnover': {'engine': 'profitability', 'method': 'asset_turnover'},
            'dupont_analysis': {'engine': 'profitability', 'method': 'dupont_analysis'},

            # ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„ÙƒÙØ§Ø¡Ø© (20)
            'inventory_turnover': {'engine': 'efficiency', 'method': 'inventory_turnover'},
            'accounts_receivable_turnover': {'engine': 'efficiency', 'method': 'accounts_receivable_turnover'},
            'accounts_payable_turnover': {'engine': 'efficiency', 'method': 'accounts_payable_turnover'},
            'total_asset_turnover': {'engine': 'efficiency', 'method': 'total_asset_turnover'},
            'fixed_asset_turnover': {'engine': 'efficiency', 'method': 'fixed_asset_turnover'},
            'working_capital_turnover': {'engine': 'efficiency', 'method': 'working_capital_turnover'},
            'cash_conversion_cycle': {'engine': 'efficiency', 'method': 'cash_conversion_cycle'},
            'receivables_to_sales_ratio': {'engine': 'efficiency', 'method': 'receivables_to_sales_ratio'},
            'inventory_to_sales_ratio': {'engine': 'efficiency', 'method': 'inventory_to_sales_ratio'},
            'operating_cycle': {'engine': 'efficiency', 'method': 'operating_cycle'},
            'employee_productivity': {'engine': 'efficiency', 'method': 'employee_productivity'},
            'cost_efficiency_ratio': {'engine': 'efficiency', 'method': 'cost_efficiency_ratio'},
            'sales_per_square_meter': {'engine': 'efficiency', 'method': 'sales_per_square_meter'},
            'marketing_efficiency_ratio': {'engine': 'efficiency', 'method': 'marketing_efficiency_ratio'},
            'operating_expense_ratio': {'engine': 'efficiency', 'method': 'operating_expense_ratio'},

            # ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© (15)
            'debt_to_equity_ratio': {'engine': 'leverage', 'method': 'debt_to_equity_ratio'},
            'debt_ratio': {'engine': 'leverage', 'method': 'debt_ratio'},
            'equity_multiplier': {'engine': 'leverage', 'method': 'equity_multiplier'},
            'times_interest_earned': {'engine': 'leverage', 'method': 'times_interest_earned'},
            'debt_service_coverage_ratio': {'engine': 'leverage', 'method': 'debt_service_coverage_ratio'},
            'long_term_debt_to_equity': {'engine': 'leverage', 'method': 'long_term_debt_to_equity'},
            'capitalization_ratio': {'engine': 'leverage', 'method': 'capitalization_ratio'},
            'financial_leverage_multiplier': {'engine': 'leverage', 'method': 'financial_leverage_multiplier'},
            'cash_coverage_ratio': {'engine': 'leverage', 'method': 'cash_coverage_ratio'},
            'degree_of_financial_leverage': {'engine': 'leverage', 'method': 'degree_of_financial_leverage'},

            # ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ (25)
            'market_capitalization': {'engine': 'market', 'method': 'market_capitalization'},
            'book_value_per_share': {'engine': 'market', 'method': 'book_value_per_share'},
            'price_to_book_ratio': {'engine': 'market', 'method': 'price_to_book_ratio'},
            'market_to_book_ratio': {'engine': 'market', 'method': 'market_to_book_ratio'},
            'enterprise_value': {'engine': 'market', 'method': 'enterprise_value'},
            'ev_to_revenue': {'engine': 'market', 'method': 'ev_to_revenue'},
            'ev_to_ebitda': {'engine': 'market', 'method': 'ev_to_ebitda'},
            'price_to_sales_ratio': {'engine': 'market', 'method': 'price_to_sales_ratio'},
            'peg_ratio': {'engine': 'market', 'method': 'peg_ratio'},

            # ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± (21)
            'net_present_value': {'engine': 'investment', 'method': 'net_present_value'},
            'internal_rate_of_return': {'engine': 'investment', 'method': 'internal_rate_of_return'},
            'payback_period': {'engine': 'investment', 'method': 'payback_period'},
            'profitability_index': {'engine': 'investment', 'method': 'profitability_index'},
            'return_on_investment_simple': {'engine': 'investment', 'method': 'return_on_investment_simple'},
            'discounted_payback_period': {'engine': 'investment', 'method': 'discounted_payback_period'},
            'modified_internal_rate_of_return': {'engine': 'investment', 'method': 'modified_internal_rate_of_return'},
            'equivalent_annual_annuity': {'engine': 'investment', 'method': 'equivalent_annual_annuity'},
        }

    def run_single_analysis(self, analysis_type: str, financial_data: Dict[str, Any]) -> Dict[str, Any]:
        """ØªØ´ØºÙŠÙ„ ØªØ­Ù„ÙŠÙ„ Ù…Ø§Ù„ÙŠ ÙˆØ§Ø­Ø¯"""
        try:
            if analysis_type not in self.available_analyses:
                return {
                    'error': f'Ù†ÙˆØ¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…: {analysis_type}',
                    'available_types': list(self.available_analyses.keys())
                }

            config = self.available_analyses[analysis_type]
            engine = self.analysis_engines[config['engine']]
            method = getattr(engine, config['method'])

            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„
            result = self._execute_analysis_method(method, financial_data)

            return {
                'analysis_type': analysis_type,
                'engine': config['engine'],
                'timestamp': datetime.now().isoformat(),
                'result': result
            }

        except Exception as e:
            self.logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ {analysis_type}: {str(e)}")
            return {
                'error': f'Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„: {str(e)}',
                'analysis_type': analysis_type
            }

    def run_comprehensive_analysis(self, financial_data: Dict[str, Any],
                                 selected_categories: List[str] = None) -> Dict[str, Any]:
        """ØªØ´ØºÙŠÙ„ ØªØ­Ù„ÙŠÙ„ Ù…Ø§Ù„ÙŠ Ø´Ø§Ù…Ù„"""
        try:
            if selected_categories is None:
                selected_categories = ['liquidity', 'profitability', 'efficiency', 'leverage', 'market', 'investment']

            results = {}

            # ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ù„ÙƒÙ„ ÙØ¦Ø© Ù…Ø®ØªØ§Ø±Ø©
            for category in selected_categories:
                if category in self.analysis_engines:
                    try:
                        # ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ Ù„Ù„ÙØ¦Ø©
                        comprehensive_method = f'comprehensive_{category}_analysis'
                        engine = self.analysis_engines[category]

                        if hasattr(engine, comprehensive_method):
                            method = getattr(engine, comprehensive_method)
                            results[category] = method(financial_data)
                        else:
                            self.logger.warning(f"Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ ØºÙŠØ± Ù…ØªÙˆÙØ± Ù„Ù„ÙØ¦Ø©: {category}")

                    except Exception as e:
                        self.logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ ÙØ¦Ø© {category}: {str(e)}")
                        results[category] = {'error': str(e)}

            # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ø§Ù…
            overall_assessment = self._create_overall_assessment(results)

            return {
                'analysis_date': datetime.now().isoformat(),
                'company_name': financial_data.get('company_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'),
                'categories_analyzed': selected_categories,
                'detailed_results': results,
                'overall_assessment': overall_assessment,
                'total_analyses': sum(len(cat_result.get('individual_analyses', {}))
                                    for cat_result in results.values()
                                    if isinstance(cat_result, dict))
            }

        except Exception as e:
            self.logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„: {str(e)}")
            return {'error': f'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„: {str(e)}'}

    def run_custom_analysis(self, analysis_list: List[str], financial_data: Dict[str, Any]) -> Dict[str, Any]:
        """ØªØ´ØºÙŠÙ„ Ù‚Ø§Ø¦Ù…Ø© Ù…Ø®ØµØµØ© Ù…Ù† Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„"""
        try:
            results = {}

            for analysis_type in analysis_list:
                result = self.run_single_analysis(analysis_type, financial_data)
                results[analysis_type] = result

            return {
                'analysis_date': datetime.now().isoformat(),
                'company_name': financial_data.get('company_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'),
                'custom_analyses': results,
                'total_analyses': len(analysis_list)
            }

        except Exception as e:
            self.logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®ØµØµ: {str(e)}")
            return {'error': f'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®ØµØµ: {str(e)}'}

    def get_analysis_recommendations(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ù…Ù† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„"""
        try:
            recommendations = {
                'priority_actions': [],
                'strengths': [],
                'weaknesses': [],
                'opportunities': [],
                'risks': []
            }

            # ØªØ­Ù„ÙŠÙ„ Ù†ØªØ§Ø¦Ø¬ ÙƒÙ„ ÙØ¦Ø©
            for category, results in analysis_results.get('detailed_results', {}).items():
                if isinstance(results, dict) and 'overall_assessment' in results:
                    assessment = results['overall_assessment']

                    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©
                    if 'recommendation_ar' in assessment:
                        recommendations['priority_actions'].append({
                            'category': category,
                            'recommendation': assessment['recommendation_ar'],
                            'priority': self._determine_priority(assessment)
                        })

            return recommendations

        except Exception as e:
            self.logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª: {str(e)}")
            return {'error': f'Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª: {str(e)}'}

    def _execute_analysis_method(self, method, financial_data: Dict[str, Any]) -> Any:
        """ØªÙ†ÙÙŠØ° Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù…Ø¹ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©"""
        try:
            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù…Ù† Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„
            import inspect
            sig = inspect.signature(method)
            params = {}

            for param_name in sig.parameters.keys():
                if param_name in financial_data:
                    params[param_name] = financial_data[param_name]

            return method(**params)

        except Exception as e:
            return {'error': f'Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„ØªØ­Ù„ÙŠÙ„: {str(e)}'}

    def _create_overall_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚ÙŠÙŠÙ… Ø¹Ø§Ù… Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„"""
        try:
            total_score = 0
            total_categories = 0
            risk_levels = []

            for category, result in results.items():
                if isinstance(result, dict) and 'overall_assessment' in result:
                    assessment = result['overall_assessment']
                    if 'overall_score' in assessment:
                        total_score += assessment['overall_score']
                        total_categories += 1

                    # Ø¬Ù…Ø¹ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø®Ø§Ø·Ø±
                    if 'risk_distribution' in assessment:
                        risk_dist = assessment['risk_distribution']
                        for risk_level, count in risk_dist.items():
                            risk_levels.extend([risk_level] * count)

            # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¹Ø§Ù…
            overall_score = total_score / total_categories if total_categories > 0 else 0

            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ø§Ù…
            if overall_score >= 4:
                overall_rating = 'Ù…Ù…ØªØ§Ø²'
                overall_rating_en = 'Excellent'
            elif overall_score >= 3:
                overall_rating = 'Ø¬ÙŠØ¯'
                overall_rating_en = 'Good'
            elif overall_score >= 2:
                overall_rating = 'Ù…Ù‚Ø¨ÙˆÙ„'
                overall_rating_en = 'Acceptable'
            else:
                overall_rating = 'ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†'
                overall_rating_en = 'Needs Improvement'

            return {
                'overall_score': round(overall_score, 2),
                'overall_rating': overall_rating,
                'overall_rating_en': overall_rating_en,
                'categories_analyzed': total_categories,
                'risk_summary': self._summarize_risks(risk_levels),
                'financial_health': self._assess_financial_health(overall_score)
            }

        except Exception as e:
            return {'error': f'Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ø§Ù…: {str(e)}'}

    def _summarize_risks(self, risk_levels: List[str]) -> Dict[str, Any]:
        """ØªÙ„Ø®ÙŠØµ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø®Ø§Ø·Ø±"""
        if not risk_levels:
            return {'total_risks': 0}

        risk_counts = {}
        for risk in risk_levels:
            risk_counts[risk] = risk_counts.get(risk, 0) + 1

        total_risks = len(risk_levels)
        high_risk_percentage = (risk_counts.get('Ø¹Ø§Ù„ÙŠ', 0) + risk_counts.get('Ø¹Ø§Ù„ÙŠ Ø¬Ø¯Ø§Ù‹', 0)) / total_risks * 100

        return {
            'total_risks': total_risks,
            'distribution': risk_counts,
            'high_risk_percentage': round(high_risk_percentage, 2),
            'overall_risk_level': self._determine_overall_risk(high_risk_percentage)
        }

    def _assess_financial_health(self, score: float) -> Dict[str, Any]:
        """ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØµØ­Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ø§Ù„Ø¹Ø§Ù…Ø©"""
        if score >= 4:
            health_status = 'Ù…Ù…ØªØ§Ø²Ø©'
            health_status_en = 'Excellent'
            description = 'Ø§Ù„Ø´Ø±ÙƒØ© ØªØªÙ…ØªØ¹ Ø¨ØµØ­Ø© Ù…Ø§Ù„ÙŠØ© Ù…Ù…ØªØ§Ø²Ø© ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª'
        elif score >= 3:
            health_status = 'Ø¬ÙŠØ¯Ø©'
            health_status_en = 'Good'
            description = 'Ø§Ù„Ø´Ø±ÙƒØ© ØªØªÙ…ØªØ¹ Ø¨ØµØ­Ø© Ù…Ø§Ù„ÙŠØ© Ø¬ÙŠØ¯Ø© Ù…Ø¹ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ù„Ù„ØªØ­Ø³ÙŠÙ†'
        elif score >= 2:
            health_status = 'Ù…Ù‚Ø¨ÙˆÙ„Ø©'
            health_status_en = 'Acceptable'
            description = 'Ø§Ù„Ø´Ø±ÙƒØ© ØªØ­ØªØ§Ø¬ Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª ÙÙŠ Ø¹Ø¯Ø© Ù…Ø¬Ø§Ù„Ø§Øª Ù…Ø§Ù„ÙŠØ©'
        else:
            health_status = 'Ø¶Ø¹ÙŠÙØ©'
            health_status_en = 'Poor'
            description = 'Ø§Ù„Ø´Ø±ÙƒØ© ØªÙˆØ§Ø¬Ù‡ ØªØ­Ø¯ÙŠØ§Øª Ù…Ø§Ù„ÙŠØ© ÙƒØ¨ÙŠØ±Ø© ØªØ­ØªØ§Ø¬ Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø¹Ø§Ø¬Ù„Ø©'

        return {
            'status': health_status,
            'status_en': health_status_en,
            'description': description,
            'score': score
        }

    def _determine_overall_risk(self, high_risk_percentage: float) -> str:
        """ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ø¹Ø§Ù…"""
        if high_risk_percentage >= 50:
            return 'Ø¹Ø§Ù„ÙŠ'
        elif high_risk_percentage >= 25:
            return 'Ù…ØªÙˆØ³Ø·'
        else:
            return 'Ù…Ù†Ø®ÙØ¶'

    def _determine_priority(self, assessment: Dict[str, Any]) -> str:
        """ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„ØªÙˆØµÙŠØ©"""
        score = assessment.get('overall_score', 3)
        if score <= 1.5:
            return 'Ø¹Ø§Ø¬Ù„'
        elif score <= 2.5:
            return 'Ø¹Ø§Ù„ÙŠ'
        elif score <= 3.5:
            return 'Ù…ØªÙˆØ³Ø·'
        else:
            return 'Ù…Ù†Ø®ÙØ¶'

    def get_available_analyses(self) -> Dict[str, Any]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø­Ø©"""
        analyses_by_category = {}

        for analysis_name, config in self.available_analyses.items():
            category = config['engine']
            if category not in analyses_by_category:
                analyses_by_category[category] = []
            analyses_by_category[category].append(analysis_name)

        return {
            'total_analyses': len(self.available_analyses),
            'categories': analyses_by_category,
            'engines': list(self.analysis_engines.keys())
        }

# Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
if __name__ == "__main__":
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠ
    engine = FinancialAnalysisEngine()

    # Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø§Ù„ÙŠØ© ØªØ¬Ø±ÙŠØ¨ÙŠØ© Ø´Ø§Ù…Ù„Ø©
    sample_financial_data = {
        # Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù…Ø©
        'company_name': 'Ø´Ø±ÙƒØ© ÙÙŠÙ† ÙƒÙ„ÙŠÙƒ Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©',
        'analysis_date': '2024-12-31',

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙŠØ²Ø§Ù†ÙŠØ© Ø§Ù„Ø¹Ù…ÙˆÙ…ÙŠØ©
        'current_assets': 500000,
        'current_liabilities': 300000,
        'inventory': 150000,
        'prepaid_expenses': 20000,
        'cash_and_equivalents': 100000,
        'short_term_investments': 50000,
        'accounts_receivable': 180000,
        'accounts_payable': 120000,
        'total_assets': 1200000,
        'total_debt': 400000,
        'shareholders_equity': 600000,
        'long_term_debt': 280000,

        # Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„
        'revenue': 1000000,
        'gross_profit': 400000,
        'operating_profit': 200000,
        'net_profit': 150000,
        'cost_of_goods_sold': 600000,
        'operating_expenses': 200000,
        'ebitda': 250000,
        'ebit': 220000,
        'interest_expense': 20000,

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙˆÙ‚
        'shares_outstanding': 100000,
        'market_price_per_share': 25,
        'book_value_per_share': 6,
        'earnings_per_share': 1.5,
        'dividends_paid': 30000,

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ø®Ø±Ù‰
        'number_of_employees': 50,
        'operating_cash_flow': 180000,
        'total_costs': 850000
    }

    print("=== Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„ - ÙÙŠÙ† ÙƒÙ„ÙŠÙƒ ===\n")

    # 1. ØªØ´ØºÙŠÙ„ ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„
    print("ğŸ” ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„...")
    comprehensive_results = engine.run_comprehensive_analysis(sample_financial_data)

    if 'error' not in comprehensive_results:
        print(f"âœ… ØªÙ… ØªØ­Ù„ÙŠÙ„ {comprehensive_results['total_analyses']} Ù…Ø¤Ø´Ø± Ù…Ø§Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­!")
        print(f"ğŸ“Š Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ø§Ù…: {comprehensive_results['overall_assessment']['overall_rating']}")
        print(f"ğŸ¥ Ø§Ù„ØµØ­Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©: {comprehensive_results['overall_assessment']['financial_health']['status']}")

        # 2. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª
        print("\nğŸ“‹ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª...")
        recommendations = engine.get_analysis_recommendations(comprehensive_results)

        if recommendations.get('priority_actions'):
            print("ğŸ¯ Ø£Ù‡Ù… Ø§Ù„ØªÙˆØµÙŠØ§Øª:")
            for rec in recommendations['priority_actions'][:3]:
                print(f"   â€¢ {rec['category']}: {rec['recommendation']} (Ø£ÙˆÙ„ÙˆÙŠØ©: {rec['priority']})")

    # 3. ØªØ´ØºÙŠÙ„ ØªØ­Ù„ÙŠÙ„ Ù…Ø®ØµØµ
    print("\nğŸ›ï¸ ØªØ´ØºÙŠÙ„ ØªØ­Ø§Ù„ÙŠÙ„ Ù…Ø®ØµØµØ©...")
    custom_analyses = ['current_ratio', 'net_profit_margin', 'debt_to_equity_ratio', 'market_capitalization']
    custom_results = engine.run_custom_analysis(custom_analyses, sample_financial_data)

    if 'error' not in custom_results:
        print(f"âœ… ØªÙ… ØªØ´ØºÙŠÙ„ {custom_results['total_analyses']} ØªØ­Ù„ÙŠÙ„ Ù…Ø®ØµØµ Ø¨Ù†Ø¬Ø§Ø­!")

    # 4. Ø¹Ø±Ø¶ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø­Ø©
    print("\nğŸ“š Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø­Ø©:")
    available = engine.get_available_analyses()
    print(f"ğŸ“ˆ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªØ­Ø§Ù„ÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø­Ø©: {available['total_analyses']}")
    for category, analyses in available['categories'].items():
        print(f"   ğŸ“ {category}: {len(analyses)} ØªØ­Ù„ÙŠÙ„")

    print("\nğŸ‰ Ø§Ù†ØªÙ‡Ù‰ Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­!")